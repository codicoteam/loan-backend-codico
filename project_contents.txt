===== server.js =====
const express = require("express");
const mongoose = require("mongoose");
const cors = require("cors");
const documentRoutes = require('./routes/documentRoutes');
app.use('/api/documents', documentRoutes);

// Ensure documents directory exists
fs.ensureDirSync(path.join(__dirname, 'documents'));
fs.ensureDirSync(path.join(__dirname, 'uploads/signatures'));
require("dotenv").config();

const app = express();

// Middleware
app.use(cors());
app.use(express.json());

// Database connection
const dbUrl = "mongodb+srv://pockettloan:pockettloan12345@pocket.sbssyen.mongodb.net/?retryWrites=true&w=majority&appName=pocket";

mongoose.connect(dbUrl, {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => console.log("Database connected successfully"))
.catch((err) => console.error("Error connecting to the database:", err));

// Import routes
const adminRouter = require("./router/admin_Route");
const userRouter = require("./router/user_Route");
const loanRouter = require("./router/loan_Route");
const paymentRouter = require("./router/payment_Route");
const kycRouter = require("./router/kyc_Route");
const notificationRouter = require("./router/notification_Route");

// Use routes
app.use("/api/v1/admin_route", adminRouter);
app.use("/api/v1/user_route", userRouter);
app.use("/api/v1/loan_route", loanRouter);
app.use("/api/v1/payment_route", paymentRouter);
app.use("/api/v1/kyc_route", kycRouter);
app.use("/api/v1/notification_route", notificationRouter);

// Create uploads directory if it doesn't exist
const fs = require('fs-extra');
fs.ensureDir('uploads/signatures').catch(err => console.error('Error creating uploads directory:', err));

const port = 5050;
app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});



===== package.json =====
{
  "name": "hcsms(backend)",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "bcrypt": "^6.0.0",
    "bcryptjs": "^3.0.2",
    "body-parser": "^1.20.3",
    "cors": "^2.8.5",
    "dotenv": "^16.5.0",
    "express": "^4.21.2",
    "fs-extra": "^11.3.1",
    "jsonwebtoken": "^9.0.2",
    "mongodb": "^6.17.0",
    "mongoose": "^8.15.1",
    "multer": "^2.0.2",
    "nodemailer": "^6.10.1",
    "paynow": "^2.2.2",
    "pdf-lib": "^1.17.1",
    "pdfmake": "^0.2.20",
    "socket.io": "^4.8.1"
  }
}



===== .env.example =====
MONGODB_URI=mongodb+srv://blessingchinozz:blessingchinozz123@hcsms.btybbip.mongodb.net/Home_Care_Service_Management_System?retryWrites=true&w=majority&appName=Hcsms
JWT_SECRET=6punvecs9gsfduj5242kcbcgdd78hrgsc5
JWT_EXPIRES_IN=90d



===== models\loan_model\loan_model.js =====
const mongoose = require("mongoose");

const addressSchema = new mongoose.Schema({
  street: String,
  city: String,
  province: String,
  phone: String,
  mobile: String,
  work: String,
  owned: Boolean,
  rentAmount: Number,
  historyYears: Number,
});

const employmentSchema = new mongoose.Schema({
  company: String,
  jobTitle: String,
  address: String,
  suburb: String,
  city: String,
  province: String,
  contactEmail: String,
  contactPhone: String,
  salary: Number,
  from: Date,
  to: Date,
});

const businessSchema = new mongoose.Schema({
  name: String,
  description: String,
  multipleLocations: Boolean,
  address: String,
  suburb: String,
  city: String,
  province: String,
  leased: Boolean,
  leaseCost: Number,
  ownPremises: Boolean,
  titleDeedAttached: Boolean,
  tradingLicenseAttached: Boolean,
  netIncome: Number,
  from: Date,
  to: Date,
});

const financialSummarySchema = new mongoose.Schema({
  salary: Number,
  hustleProfit: Number,
  businessExpenses: Number,
  bonuses: Number,
  rent: Number,
  rentalIncome: Number,
  schoolFees: Number,
  investmentIncome: Number,
  ratesAndBills: Number,
  otherIncome: Number,
  loanRepayments: Number,
  otherDebts: Number,
  totalIncome: Number,
  totalExpenses: Number,
  netIncome: Number,
});

const assetLiabilitySchema = new mongoose.Schema({
  assets: {
    property: [String],
    vehicles: [String],
    furniture: Number,
    machinery: Number,
    artwork: Number,
    shares: [String],
    pension: Number,
    mutualFunds: Number,
    total: Number,
  },
  liabilities: {
    mortgages: [Number],
    bankLoans: [Number],
    retailLoans: [String],
    otherDebts: [String],
    total: Number,
  },
  net: Number,
});

const bankReferenceSchema = new mongoose.Schema({
  institution: String,
  currentAccount: String,
  savingsAccount: String,
  loanNumber: String,
  loanBalance: Number,
  branch: String,
});

const paymentScheduleSchema = new mongoose.Schema({
  dueDate: Date,
  amountDue: Number,
  amountPaid: Number,
  paidOn: Date,
  status: {
    type: String,
    enum: ["pending", "paid", "overdue"],
    default: "pending",
  },
});

const loanSchema = new mongoose.Schema(
  {
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      required: true,
    },
    productType: {
      type: String,
      enum: [
        "Education Loan (Short Term)",
        "Vehicle Loan (Long Term)",
        "Solar Loan (LT)",
        "Building Finisher Loan (LT)",
      ],
      required: true,
    },
    borrowerInfo: {
      firstName: String,
      middleNames: String,
      surname: String,
      alias: String,
      idNumber: String,
      passport: String,
      email: String,
      phone: String,
      mobile: String,
      ecocash: Boolean,
      oneMoney: Boolean,
      innsBucks: Boolean,
      maritalStatus: String,
      children: Number,
      childrenUnder18: Number,
      dependents: Number,
    },
    documentTracking: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'DocumentTracking',
      default: null
    },
    agreementPdf: String,
    signedAt: Date,
    signedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
      default: null
    },
    spouseInfo: {
      employed: Boolean,
      firstName: String,
      middleNames: String,
      surname: String,
      alias: String,
      idNumber: String,
      passport: String,
      phone: String,
      mobile: String,
      email: String,
      ecocash: Boolean,
      oneMoney: Boolean,
      innsBucks: Boolean,
    },
    residentialHistory: {
      currentAddress: addressSchema,
      previousAddress: addressSchema,
      landlordName: String,
      rentalCompany: String,
    },
    borrowerEmploymentHistory: [employmentSchema],
    borrowerBusinessHistory: [businessSchema],
    spouseEmploymentHistory: [employmentSchema],
    spouseBusinessHistory: [businessSchema],
    financialSummary: financialSummarySchema,
    borrowerAssetsLiabilities: assetLiabilitySchema,
    spouseAssetsLiabilities: assetLiabilitySchema,
    bankReferences: [bankReferenceSchema],
    bankruptcy: {
      hasDeclared: Boolean,
      declaredDate: Date,
    },
    status: {
      type: String,
      enum: ["pending", "approved", "rejected", "active", "closed"],
      default: "pending",
    },
    applicationDate: {
      type: Date,
      default: Date.now,
    },
    approvalDate: Date,
    startDate: Date,
    endDate: Date,
    amount: Number,
    interestRate: Number,
    term: Number,
    balance: Number,
    paymentSchedule: [paymentScheduleSchema],
  },
  {
    timestamps: true,
  }
);

module.exports = mongoose.model("Loan", loanSchema);



===== models\user_model.js =====
const mongoose = require("mongoose");
const bcrypt = require("bcryptjs");

const userSchema = new mongoose.Schema(
  {
    firstName: {
      type: String,
      required: [true, "First name is required"],
      trim: true
    },
    lastName: {
      type: String,
      required: [true, "Last name is required"],
      trim: true
    },
    email: {
      type: String,
      unique: true,
      required: [true, "Email is required"],
      lowercase: true,
      trim: true,
      match: [/^\w+([\.-]?\w+)*@\w+([\.-]?\w+)*(\.\w{2,3})+$/, "Please fill a valid email address"]
    },
    phoneNumber: {
      type: String,
      required: [true, "Phone number is required"],
      trim: true
    },
    password: {
      type: String,
      required: [true, "Password is required"],
      minlength: [6, "Password must be at least 6 characters"],
      select: false // Don't return password in queries by default
    },
    address: {
      type: String,
      required: [true, "Address is required"],
      trim: true
    },
    profilePicture: {
      type: String,
      default: ""
    },
    role: {
      type: String,
      enum: ["customer", "agent", "admin"],
      default: "customer",
      required: true
    },
    createdByAgent: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
      default: null
    },
    isActive: {
      type: Boolean,
      default: true
    },
    lastLogin: {
      type: Date
    }
  },
  {
    timestamps: true,
    toJSON: {
      virtuals: true,
      transform: function(doc, ret) {
        delete ret.password; // Never return password in JSON responses
        return ret;
      }
    },
    toObject: {
      virtuals: true
    }
  }
);

// Password hashing middleware
userSchema.pre("save", async function(next) {
  if (!this.isModified("password")) return next();
  
  try {
    this.password = await bcrypt.hash(this.password, 12);
    next();
  } catch (err) {
    next(err);
  }
});

userSchema.pre("findOneAndUpdate", async function(next) {
  const update = this.getUpdate();
  if (update.password) {
    try {
      update.password = await bcrypt.hash(update.password, 12);
      next();
    } catch (err) {
      next(err);
    }
  } else {
    next();
  }
});

// Method to compare passwords
userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

// Virtual for full name
userSchema.virtual("fullName").get(function() {
  return `${this.firstName} ${this.lastName}`;
});
// Add this method to your user_model.js, right before module.exports
userSchema.methods.changedPasswordAfter = function(JWTTimestamp) {
  if (this.passwordChangedAt) {
    const changedTimestamp = parseInt(
      this.passwordChangedAt.getTime() / 1000,
      10
    );
    return JWTTimestamp < changedTimestamp;
  }

  // False means NOT changed
  return false;
};
userSchema.methods.changedPasswordAfter = function(JWTTimestamp) {
  if (this.passwordChangedAt) {
    const changedTimestamp = parseInt(
      this.passwordChangedAt.getTime() / 1000,
      10
    );
    return JWTTimestamp < changedTimestamp;
  }
  return false;
};
module.exports = mongoose.model("User", userSchema);



===== models\DocumentTracking.js =====
const mongoose = require('mongoose');

const documentTrackingSchema = new mongoose.Schema({
  loanId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Loan',
    required: true
  },
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  unsignedDocPath: {
    type: String,
    required: true
  },
  signedDocPath: String,
  signaturePath: String,
  isSigned: {
    type: Boolean,
    default: false
  },
  signedAt: Date,
  signingIP: String,
  signingDevice: String,
  versions: [{
    docPath: String,
    signed: Boolean,
    createdAt: {
      type: Date,
      default: Date.now
    }
  }]
}, { timestamps: true });

module.exports = mongoose.model('DocumentTracking', documentTrackingSchema);



===== models\Document_model\document.js =====
const mongoose = require("mongoose");

const documentSchema = new mongoose.Schema(
  {
    loan: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "Loan",
      required: true,
    },
    uploadedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: "User",
    },
    type: {
      type: String,
      enum: [
        "id",
        "passport",
        "proof_of_income",
        "payslip",
        "title_deed",
        "license",
        "other",
      ],
      required: true,
    },
    fileName: String,
    fileUrl: String,
    fileSize: Number, // in bytes
    mimeType: String,
    uploadedAt: {
      type: Date,
      default: Date.now,
    },
  },
  {
    timestamps: true,
  }
);

module.exports = mongoose.model("Document", documentSchema);



===== services\pdfService.js =====
const fs = require('fs-extra');
const path = require('path');
const PdfPrinter = require('pdfmake');
const { PDFDocument, rgb } = require('pdf-lib');

const fonts = {
  Roboto: {
    normal: 'Helvetica',
    bold: 'Helvetica-Bold',
    italics: 'Helvetica-Oblique',
    bolditalics: 'Helvetica-BoldOblique'
  }
};

const printer = new PdfPrinter(fonts);
const tempDir = path.join(__dirname, '../documents');
const signaturesDir = path.join(__dirname, '../uploads/signatures');

fs.ensureDirSync(tempDir);
fs.ensureDirSync(signaturesDir);

const pdfService = {
  generateLoanAgreement: async (loan, user) => {
    const docDefinition = {
      content: [
        { text: 'LOAN AGREEMENT', style: 'header' },
        { text: `Generated: ${new Date().toLocaleString()}`, style: 'subheader' },
        { 
          table: {
            widths: ['30%', '70%'],
            body: [
              ['Loan ID', loan._id.toString()],
              ['Borrower', `${loan.borrowerInfo.firstName} ${loan.borrowerInfo.surname}`],
              ['ID Number', loan.borrowerInfo.idNumber || 'Not provided'],
              ['Product Type', loan.productType],
              ['Amount', `$${loan.amount.toLocaleString()}`],
              ['Term', `${loan.term} months`],
              ['Interest Rate', `${loan.interestRate}%`]
            ]
          }
        },
        { text: 'Signatures', style: 'signatureHeader', margin: [0, 30, 0, 10] },
        {
          columns: [
            { text: '__________________\nLender Representative', width: '50%' },
            { text: '__________________\nBorrower', width: '50%' }
          ]
        }
      ],
      styles: {
        header: { fontSize: 18, bold: true, alignment: 'center' },
        subheader: { fontSize: 10, alignment: 'center', margin: [0, 0, 0, 10] },
        signatureHeader: { bold: true, alignment: 'center' }
      },
      defaultStyle: { font: 'Roboto' }
    };

    const pdfPath = path.join(tempDir, `loan_agreement_${loan._id}.pdf`);
    const pdfDoc = printer.createPdfKitDocument(docDefinition);
    
    await new Promise((resolve, reject) => {
      const stream = fs.createWriteStream(pdfPath);
      pdfDoc.pipe(stream);
      pdfDoc.on('end', resolve);
      pdfDoc.on('error', reject);
      pdfDoc.end();
    });

    return pdfPath;
  },

  signLoanAgreement: async (unsignedPath, signaturePath, outputPath) => {
    const pdfBytes = await fs.readFile(unsignedPath);
    const pdfDoc = await PDFDocument.load(pdfBytes);
    const page = pdfDoc.getPages()[0];

    if (await fs.pathExists(signaturePath)) {
      const imageBytes = await fs.readFile(signaturePath);
      let image;

      if (signaturePath.endsWith('.png')) {
        image = await pdfDoc.embedPng(imageBytes);
      } else if (signaturePath.endsWith('.jpg') || signaturePath.endsWith('.jpeg')) {
        image = await pdfDoc.embedJpg(imageBytes);
      }

      page.drawImage(image, {
        x: 350,
        y: 100,
        width: 120,
        height: 60
      });

      page.drawText(`Signed at: ${new Date().toLocaleString()}`, {
        x: 350,
        y: 80,
        size: 8,
        color: rgb(0.3, 0.3, 0.3)
      });
    }

    await fs.writeFile(outputPath, await pdfDoc.save());
    return outputPath;
  }
};

module.exports = pdfService;



===== router\documentRoutes.js =====
const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');
const fs = require('fs-extra');
const Loan = require('../models/loan_model/loan_model');
const User = require('../models/User');
const DocumentTracking = require('../models/DocumentTracking');
const pdfService = require('../services/pdfService');

const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    fs.mkdirsSync(path.join(__dirname, '../uploads/signatures'));
    cb(null, path.join(__dirname, '../uploads/signatures'));
  },
  filename: (req, file, cb) => {
    cb(null, `${req.user.id}-${Date.now()}${path.extname(file.originalname)}`);
  }
});

const upload = multer({ 
  storage,
  limits: { fileSize: 2 * 1024 * 1024 },
  fileFilter: (req, file, cb) => {
    if (['image/png', 'image/jpeg'].includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Only PNG/JPEG images allowed'), false);
    }
  }
});

router.post('/:loanId/generate', async (req, res) => {
  try {
    const loan = await Loan.findById(req.params.loanId);
    const user = await User.findById(loan.user);

    let tracking = await DocumentTracking.findOne({ loanId: loan._id });
    if (tracking) {
      return res.json({
        success: true,
        message: 'Document already exists',
        documentId: tracking._id,
        pdfUrl: `/documents/${loan._id}/unsigned`
      });
    }

    const pdfPath = await pdfService.generateLoanAgreement(loan, user);
    
    tracking = new DocumentTracking({
      loanId: loan._id,
      userId: user._id,
      unsignedDocPath: pdfPath
    });
    await tracking.save();

    loan.documentTracking = tracking._id;
    await loan.save();

    res.json({
      success: true,
      documentId: tracking._id,
      pdfUrl: `/documents/${loan._id}/unsigned`
    });
  } catch (error) {
    res.status(500).json({ 
      success: false,
      message: error.message 
    });
  }
});

router.post('/:documentId/sign', upload.single('signature'), async (req, res) => {
  try {
    const tracking = await DocumentTracking.findById(req.params.documentId);
    const loan = await Loan.findById(tracking.loanId);

    if (tracking.isSigned) {
      return res.status(400).json({
        success: false,
        message: 'Document already signed'
      });
    }

    if (!req.file) {
      return res.status(400).json({
        success: false,
        message: 'Signature image is required'
      });
    }

    const signedPath = path.join(__dirname, '../documents', `loan_${loan._id}_signed.pdf`);
    await pdfService.signLoanAgreement(
      tracking.unsignedDocPath,
      req.file.path,
      signedPath
    );

    tracking.signedDocPath = signedPath;
    tracking.signaturePath = req.file.path;
    tracking.isSigned = true;
    tracking.signedAt = new Date();
    tracking.signingIP = req.ip;
    tracking.signingDevice = req.headers['user-agent'];
    await tracking.save();

    loan.agreementPdf = signedPath;
    loan.signedAt = new Date();
    loan.signedBy = req.user.id;
    await loan.save();

    res.json({
      success: true,
      signedDocumentUrl: `/documents/${loan._id}/signed`
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

router.get('/:loanId/status', async (req, res) => {
  try {
    const tracking = await DocumentTracking.findOne({ loanId: req.params.loanId });
    
    if (!tracking) {
      return res.json({
        exists: false,
        isSigned: false 
      });
    }

    res.json({
      exists: true,
      isSigned: tracking.isSigned,
      signedAt: tracking.signedAt,
      unsignedUrl: `/documents/${req.params.loanId}/unsigned`,
      signedUrl: tracking.isSigned ? `/documents/${req.params.loanId}/signed` : null
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

router.get('/:loanId/:type(unsigned|signed)', async (req, res) => {
  try {
    const tracking = await DocumentTracking.findOne({ loanId: req.params.loanId });
    const filePath = req.params.type === 'unsigned' 
      ? tracking.unsignedDocPath 
      : tracking.signedDocPath;

    if (!filePath || !fs.existsSync(filePath)) {
      return res.status(404).json({
        success: false,
        message: 'Document not found'
      });
    }

    res.download(filePath);
  } catch (error) {
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

module.exports = router;



===== middlewares\auth.js =====
const jwt = require('jsonwebtoken');
const User = require('../models/user_model');

const auth = {
  // Verify JWT token
  authenticateToken: async (req, res, next) => {
    try {
      // 1) Get token from header
      let token;
      if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
        token = req.headers.authorization.split(' ')[1];
      }

      if (!token) {
        return res.status(401).json({
          success: false,
          message: 'Authorization token is required'
        });
      }

      // 2) Verify token
      const decoded = jwt.verify(token, process.env.JWT_SECRET || 'Pocket_2025');

      // 3) Check if user exists
      const currentUser = await User.findById(decoded.id).select('+passwordChangedAt');
      if (!currentUser) {
        return res.status(401).json({
          success: false,
          message: 'User account not found'
        });
      }

      // 4) Check if password was changed after token issued
      if (currentUser.changedPasswordAfter && currentUser.changedPasswordAfter(decoded.iat)) {
        return res.status(401).json({
          success: false,
          message: 'Password was changed recently. Please log in again.'
        });
      }

      // 5) Attach user to request
      req.user = currentUser;
      next();
    } catch (error) {
      // Handle specific JWT errors
      if (error.name === 'JsonWebTokenError') {
        return res.status(401).json({
          success: false,
          message: 'Invalid authentication token'
        });
      }
      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({
          success: false,
          message: 'Session expired. Please log in again.'
        });
      }

      // Generic error handler
      console.error('Authentication error:', error);
      return res.status(500).json({
        success: false,
        message: 'Internal server error during authentication'
      });
    }
  },

  // Role-based access control
  restrictTo: (...allowedRoles) => {
    return (req, res, next) => {
      if (!allowedRoles.includes(req.user.role)) {
        return res.status(403).json({
          success: false,
          message: 'You are not authorized to perform this action'
        });
      }
      next();
    };
  },

  // Token generation
  signToken: (userId, userRole, expiresIn = '30d') => {
    return jwt.sign(
      { id: userId, role: userRole },
      process.env.JWT_SECRET || 'Pocket_2025',
      { expiresIn }
    );
  },

  // Create and send token (for login/signup)
  createSendToken: (user, statusCode, res) => {
    const token = auth.signToken(user._id, user.role);
    
    // Remove password from output
    user.password = undefined;
    user.passwordChangedAt = undefined;

    res.status(statusCode).json({
      success: true,
      token,
      data: {
        user
      }
    });
  }
};

module.exports = auth;



